`timescale 1ns/1ps
module tb_CORE_seg_gmodel();
	localparam T = 20;

	//inout single-cylce
	logic [31:0] instr, datareg_wr, PC, alu_out_ext, dataram_wr, dataram_rd_sig;
	logic CLOCK, RST_n, ena_wr, ena_rd, MemtoReg_sig;
	
	// inout segmentado
	logic [31:0] alu_out_ext_seg, PC_seg, dataram_wr_seg;
	logic ena_wr_seg, ena_rd_seg;
		
	logic [31:0] [31:0] registro; //x0=registro[0],x1=registro[1], ect
	logic [31:0] rs1, rs2, inm_ext_32, PC_esperado1, PC_esperado2, expected_addr, rd_addr_value; // Contenido de 32 bits
	logic [11:0] inm_orshamt, inm;
	logic [2:0] func3;
	logic [31:0] resultado_esperado, resultado_singlecy;
	logic true_false;
	logic [19:0] inm_tipoU;
	logic [20:0] inm_Jal;
	logic [4:0] rd_addr;
	
	TOP_CORE duv_gmodel
	(
		.instr(instr) ,	// input [31:0] instr_sig
		.dataram_rd(alu_out_ext) ,	// input [31:0] datareg_wr_sig
		.CLOCK(CLOCK) ,	// input  CLOCK_sig
		.RST_n(RST_n) ,	// input  RST_n_sig
		.PC(PC) ,	// output [31:0] PC_sig
		.ena_wr(ena_wr) ,	// output  ena_wr_sig
		.ena_rd(ena_rd) ,	// output  ena_rd_sig
		.alu_out_ext(alu_out_ext) ,	// output [31:0] alu_out_ext_sig
		.dataram_wr(dataram_wr) 	// output [31:0] dataram_wr_sig
	);
	
	TOP_CORE_seg duv_seg
	(
		.instr(instr) ,	// input [31:0] instr_sig
		.dataram_rd(alu_out_ext_seg) ,	// input [31:0] datareg_wr_sig
		.CLOCK(CLOCK) ,	// input  CLOCK_sig
		.RST_n(RST_n) ,	// input  RST_n_sig
		.PC(PC_seg) ,	// output [31:0] PC_sig
		.ena_wr(ena_wr_seg) ,	// output  ena_wr_sig
		.ena_rd(ena_rd_seg) ,	// output  ena_rd_sig
		.alu_out_ext(alu_out_ext_seg) ,	// output [31:0] alu_out_ext_sig
		.dataram_wr(dataram_wr_seg) 	// output [31:0] dataram_wr_sig
	);
	
	class instruccionRandom;
		rand logic [31:0] instr;

		constraint R_format {
			instr[6:0] == 7'b0110011;
			instr[31:25] == 7'b0000000 ||
			instr[31:25] == 7'b0100000 && instr[14:12] == 3'b000 ||
			instr[31:25] == 7'b0100000 && instr[14:12] == 3'b101;
		} 
				
		constraint I_format {
			instr[6:0] == 7'b0010011;
			
			(instr[14:12] == 3'b001) -> (instr[31:25] == 7'b0000000);
			(instr[14:12] == 3'b101) -> (instr[31:25] inside {7'b0000000, 7'b0100000});
		}
		
		
		constraint B_format {
			instr[6:0] == 7'b1100011;
			instr[14:12] == 3'b000 ||
			instr[14:12] == 3'b001 ||
			instr[14:12] == 3'b100 ||
			instr[14:12] == 3'b101 ||
			instr[14:12] == 3'b110 ||
			instr[14:12] == 3'b111;		
		}
		
		constraint U_format {
			instr[6:0] == 7'b0010111 || instr[6:0] == 7'b0110111; //AUIPC or LUI
		}
		
		constraint carga_format {
			instr[6:0] == 7'b0000011;
			instr[14:12] == 3'b010;
		}
		
		constraint S_format {
			instr[6:0] == 7'b0100011;
			instr[14:12] == 3'b010;
		}
		
		constraint Jal_format {
			instr[6:0] == 7'b1101111;
		}
		
		constraint Jalr_format {
			instr[6:0] == 7'b1100111;
			instr[14:12] == 3'b000;
		}
	endclass


	// --- COVERGROUPS ---
	
	// R_TYPE (ACTIVO)
	covergroup R_type;
		rd_cp: coverpoint instr[11:7] {
			bins val[] = {[0:31]};
		}
		rs1_cp: coverpoint instr[19:15] {
			bins val[4] = {[0:31]};
		}
		rs2_cp: coverpoint instr[24:20] {
			bins val[4] = {[0:31]};
		}
		func3_cp: coverpoint instr[14:12] {
			bins val[] = {[0:7]};
		}
		cruceR: cross rd_cp, rs1_cp, rs2_cp, func3_cp;
	endgroup;
	
	
	
	covergroup I_type;
		rd_cp: coverpoint instr[11:7] {
			bins val[] = {[0:31]};
		}
		rs1_cp: coverpoint instr[19:15] {
			bins val[4] = {[0:31]};
		}
		func3_cp: coverpoint instr[14:12] {
			bins val[] = {[0:7]};
		}
		inm_cp: coverpoint $signed(instr[31:20]) {
			bins val[4] = {[-2048:2047]};
		} 
		cruceI: cross rd_cp, rs1_cp, func3_cp, inm_cp;
	endgroup;


	covergroup B_type; 
		rs1_cp: coverpoint instr[19:15] {
			bins val[4] = {[0:31]};
		}
		rs2_cp: coverpoint instr[24:20] {
			bins val[4] = {[0:31]};
		}
		func3_cp: coverpoint instr[14:12] {
			bins val[] = {[0:7]};
		}
		inm_cp: coverpoint $signed({instr[31],instr[7],instr[30:25],instr[11:8]}) {
			bins val[4] = {[-2048:2047]};
		}
		cruceB: cross rs1_cp, rs2_cp, inm_cp;
	endgroup;
	
	covergroup U_type; 
		rd_cp: coverpoint instr[11:7] {
			bins val[] = {[0:31]};
		}
		inm_cp: coverpoint $signed({instr[31:12]}) {
			bins val[8] = {[-524288:524287]};
		}
		cruceU: cross rd_cp, inm_cp;
	endgroup;

	covergroup carga_type;
		inm_cp: coverpoint $signed({instr[31:20]}) {
			bins val[8] = {[-2048:2047]};
		}
		rs1_cp: coverpoint instr[19:15] {
			bins val[4] = {[0:31]};
		}
		rd_cp: coverpoint instr[11:7] {
			bins val[] = {[0:31]};
		}
		cruce_carg: cross inm_cp, rs1_cp, rd_cp;
	endgroup;
	
	covergroup S_type;
		inm_cp: coverpoint $signed({instr[31:25],instr[11:7]}) {
			bins val[] = {[-2048:2047]};
		}
		rs1_cp: coverpoint instr[19:15] {
			bins val[4] = {[0:31]};
		}
		cruceS: cross inm_cp, rs1_cp;
	endgroup;
	
	covergroup Jal_type;
		inm_cp: coverpoint $signed({instr[31:12]})	{
			bins val[4] = {[-524288:524287]};
		}
		rd_cp: coverpoint instr[11:7] {
			bins val[] = {[0:31]};
		}
		cruceJal: cross rd_cp, inm_cp;
	endgroup;
	
	covergroup Jalr_type;
		inm_cp: coverpoint $signed({instr[31:20]})	{
			bins val[4] = {[-2048:2047]};
		}
		rs1_cp: coverpoint instr[19:15] {
			bins val[4] = {[0:31]};
		}
		rd_cp: coverpoint instr[11:7] {
			bins val[] = {[0:31]};
		}
		cruceJalr: cross rd_cp, inm_cp, rs1_cp;
	endgroup;
	
	//Declaracion de objetos
	instruccionRandom busInst = new;
	R_type veamosR = new;
	I_type veamosI = new;
	B_type veamosB = new;
	U_type veamosU = new;
	carga_type veamos_car = new;
	S_type veamosS = new;
	Jal_type veamosJal = new;
	Jalr_type veamosJalr = new;
	
	//DEFINICION DEL CLOCK
	always
	begin
		#(T/2) CLOCK = ~CLOCK;
	end
	
	// TASK PARA INICIALIZAR REGISTROS (Evita valores 'X')
	task init_registros;
		// Declara una variable temporal
		logic [31:0] valor_random; 
		begin
			for (int i = 0; i < 32; i++) begin
				valor_random = $random; // Generas el valor una vez
				
				duv_gmodel.banco_registros_inst.registro[i] = valor_random;  // Se lo das al Golden Model
				duv_seg.banco_registros_inst.registro[i] = valor_random; // ¡Se lo das también al Segmentado!
			end
			// Asegura R0 en ambos
			duv_gmodel.banco_registros_inst.registro[0] = 32'h0;
			duv_seg.banco_registros_inst.registro[0] = 32'h0;
		end
	endtask
	
	assign registro = duv_gmodel.banco_registros_inst.registro;
	
	task R_instructions;
			begin
				// 2. INICIO DE LA LÓGICA
				busInst.R_format.constraint_mode(1);
				busInst.I_format.constraint_mode(0);
				busInst.B_format.constraint_mode(0);
				busInst.U_format.constraint_mode(0);
				busInst.carga_format.constraint_mode(0);
				busInst.S_format.constraint_mode(0);
				busInst.Jalr_format.constraint_mode(0);
				busInst.Jal_format.constraint_mode(0);
				
				assert(busInst.randomize()) else $error("Falló randomize()");
				instr = busInst.instr; 
				
				@(negedge CLOCK);
				resultado_singlecy = alu_out_ext;
				repeat(4) @(negedge CLOCK);
				assert (resultado_singlecy == alu_out_ext_seg) else $error("operacion tipo R mal realizada");

				veamosR.sample();
			end
		endtask
	
	task I_instructions;
		begin
			busInst.R_format.constraint_mode(0);
			busInst.I_format.constraint_mode(1);
			busInst.B_format.constraint_mode(0);
			busInst.U_format.constraint_mode(0);
			busInst.carga_format.constraint_mode(0);
			busInst.S_format.constraint_mode(0);
			busInst.Jalr_format.constraint_mode(0);
			busInst.Jal_format.constraint_mode(0);
			
			assert(busInst.randomize()) else $error("Falló randomize()");
			instr = busInst.instr;
			
			@(negedge CLOCK);
			resultado_singlecy = alu_out_ext;
			repeat(4) @(negedge CLOCK);
			assert (resultado_singlecy == alu_out_ext_seg) else $error("operacion tipo I mal realizada");

			veamosI.sample();
			
		end
	endtask
	
	task B_instructions;
		begin
			busInst.R_format.constraint_mode(0);
			busInst.I_format.constraint_mode(0);
			busInst.B_format.constraint_mode(1);
			busInst.U_format.constraint_mode(0);
			busInst.carga_format.constraint_mode(0);
			busInst.S_format.constraint_mode(0);
			busInst.Jalr_format.constraint_mode(0);
			busInst.Jal_format.constraint_mode(0);
			
			assert(busInst.randomize()) else $error("Falló randomize()");
			instr = busInst.instr;
			
			rs1 = registro[instr[19:15]];
			rs2 = registro[instr[24:20]];
			func3 = instr[14:12];
			inm = {instr[31], instr[7], instr[30:25], instr[11:8]};
			inm_ext_32 = {{19{instr[31]}}, inm, 1'b0};
			
						
			case(func3)
			   3'b000: true_false = (rs1 == rs2); // BEQ  → SUB
			   3'b001: true_false = (rs1 != rs2); // BNE  → SUB (cambiado)
			   3'b100: true_false = ($signed(rs1) < $signed(rs2)); // BLT  → SLT
			   3'b110: true_false = (rs1 < rs2); // BLTU → SLTU
			   3'b101: true_false = ($signed(rs1) >= $signed(rs2)); // BGE  → SLT
			   3'b111: true_false = (rs1 >= rs2); // BGEU → SLTU
			   default: true_false = 1'b0;
			endcase
			
			repeat(2) @(negedge CLOCK);
			resultado_singlecy = PC;
			
			if (true_false == 1'b1)
				begin
				repeat(3) @(negedge CLOCK);
				assert (resultado_singlecy == PC_seg) else $error("operacion tipo B mal realizada"); //si se le suma el inmediato tarda
				end
			else if (true_false == 1'b0)
				begin
				assert (resultado_singlecy == PC_seg) else $error("operacion tipo B mal realizada"); //si no se suma 4
				end

			veamosB.sample();
			
		end
	endtask
	
	task U_instructions;
		begin
			busInst.R_format.constraint_mode(0);
			busInst.I_format.constraint_mode(0);
			busInst.B_format.constraint_mode(0);
			busInst.U_format.constraint_mode(1);
			busInst.carga_format.constraint_mode(0);
			busInst.S_format.constraint_mode(0);
			busInst.Jalr_format.constraint_mode(0);
			busInst.Jal_format.constraint_mode(0);
			
			assert(busInst.randomize()) else $error("Falló randomize()");
			instr = busInst.instr;

			@(negedge CLOCK);
			resultado_singlecy = alu_out_ext;
			
			repeat(3) @(negedge CLOCK);
			//if (instr[6:0] == 7'b0010111)
			assert (resultado_singlecy == alu_out_ext_seg) else $error("operacion tipo U mal realizada");
			//else 
				
			veamosU.sample();

				
		end
	endtask
	
	task carga_instructions;
		begin
			busInst.R_format.constraint_mode(0);
			busInst.I_format.constraint_mode(0);
			busInst.B_format.constraint_mode(0);
			busInst.U_format.constraint_mode(0);
			busInst.carga_format.constraint_mode(1);
			busInst.S_format.constraint_mode(0);
			busInst.Jalr_format.constraint_mode(0);
			busInst.Jal_format.constraint_mode(0);
			
			assert(busInst.randomize()) else $error("Falló randomize()");
			instr = busInst.instr;
			
			@(negedge CLOCK);
			resultado_singlecy = alu_out_ext;
			repeat(4) @(negedge CLOCK);
			assert (resultado_singlecy == alu_out_ext_seg) else $error("la direccion en la operacion de carga no es correcta");

			veamos_car.sample();
			
		end
	endtask

	task S_instructions;
		begin
			busInst.R_format.constraint_mode(0);
			busInst.I_format.constraint_mode(0);
			busInst.B_format.constraint_mode(0);
			busInst.U_format.constraint_mode(0);
			busInst.carga_format.constraint_mode(0);
			busInst.S_format.constraint_mode(1);
			busInst.Jalr_format.constraint_mode(0);
			busInst.Jal_format.constraint_mode(0);
			
			assert(busInst.randomize()) else $error("Falló randomize()");
			instr = busInst.instr;
			
			@(negedge CLOCK);
			resultado_singlecy = alu_out_ext;
			
			repeat(4) @(negedge CLOCK);
			assert (resultado_singlecy == alu_out_ext_seg) else $error("la direccion en la operacion de store word no es correcta");

			veamosS.sample();
			
		end
	endtask
	
	task Jal_instructions;
		begin
			busInst.R_format.constraint_mode(0);
			busInst.I_format.constraint_mode(0);
			busInst.B_format.constraint_mode(0);
			busInst.U_format.constraint_mode(0);
			busInst.carga_format.constraint_mode(0);
			busInst.S_format.constraint_mode(0);
			busInst.Jalr_format.constraint_mode(0);
			busInst.Jal_format.constraint_mode(1);
			
			assert(busInst.randomize()) else $error("Falló randomize()");
			instr = busInst.instr;
			
			repeat(2) @(negedge CLOCK);
			resultado_singlecy = PC;
			repeat(3) @(negedge CLOCK);
			assert (resultado_singlecy == PC_seg) else $error("El salto en PC no se ha realizado de manera correcta");
	
			veamosJal.sample();
			
		end
	endtask
	
	task Jalr_instructions;
		begin
			busInst.R_format.constraint_mode(0);
			busInst.I_format.constraint_mode(0);
			busInst.B_format.constraint_mode(0);
			busInst.U_format.constraint_mode(0);
			busInst.carga_format.constraint_mode(0);
			busInst.S_format.constraint_mode(0);
			busInst.Jalr_format.constraint_mode(1);
			busInst.Jal_format.constraint_mode(0);
			
			assert(busInst.randomize()) else $error("Falló randomize()");
			instr = busInst.instr;
			
			repeat(2) @(negedge CLOCK);
			resultado_singlecy = PC;
			repeat(3) @(negedge CLOCK);
			assert (resultado_singlecy == PC_seg) else $error("El salto en PC no se ha realizado de manera correcta");

			veamosJalr.sample();
			
		end
	endtask

	
	task reset;
		begin
			RST_n = 1'b0; // Activamos Reset
			
			instr = 32'h00000000; 
			datareg_wr = 32'b0; 
			// ----------------------------------------

			@(negedge CLOCK); // Esperamos unos ciclos con el Reset activo
			RST_n = 1'b1; // Soltamos Reset
		end
		endtask
			
	initial
	begin
		CLOCK = 0;
		// Inicializamos memoria		
		reset();
		
  		@(negedge CLOCK);
		while (veamosR.cruceR.get_coverage() < 70)
			
			begin
				#5
				reset();
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(15) @(posedge CLOCK);
				#2
				R_instructions;
			end

		@(negedge CLOCK);
		while (veamosI.cruceI.get_coverage() < 70)
			
			begin
				#5
				reset();
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(15) @(posedge CLOCK);
				#2
				I_instructions;
			end
			 
		@(negedge CLOCK);
		while (veamosB.cruceB.get_coverage() < 100)
			
			begin
				// #5
				reset();
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(7) @(posedge CLOCK);
				#2
				B_instructions;
			end
			
 		@(negedge CLOCK);
		while (veamosU.cruceU.get_coverage() < 100)
			
			begin
				// #5
				reset();
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(15) @(posedge CLOCK);
				#2
				U_instructions;
			end 
			
		 @(negedge CLOCK);
		 while (veamos_car.cruce_carg.get_coverage() < 50)
			
			 begin
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(15) @(posedge CLOCK);
				#2
				 carga_instructions;
			 end
			 
		 @(negedge CLOCK);
		 while (veamosS.cruceS.get_coverage() < 50)
			
			 begin
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(15) @(posedge CLOCK);
				#2
				 S_instructions;
			 end
 
		@(negedge CLOCK);
		 while (veamosJal.cruceJal.get_coverage() < 50)
			
			 begin
				repeat(2) @(negedge CLOCK);
				reset();
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(15) @(posedge CLOCK);
				#2
				 Jal_instructions;
			 end
		 
		@(negedge CLOCK);
		 while (veamosJalr.cruceJalr.get_coverage() < 50)
			
			 begin
				repeat(2) @(negedge CLOCK);
				reset();
				repeat(4) @(posedge CLOCK);
				init_registros();
				repeat(15) @(posedge CLOCK);
				#5
				 Jalr_instructions;
			 end
		 
		$display("Test finished");
		$stop;	
	end
	
	
endmodule
